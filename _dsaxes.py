"""
===============
Resampling Data
===============

Downsampled plotting of matplotlib.lines.Line2D objects
and interactive legend

Author: Erik Benkler
Physikalisch-Technische Bundesanstalt Braunschweig

"""
import warnings
import matplotlib.dates as mdates
import matplotlib.units as munits
import pandas as pd
import os
import inspect
import numpy as np
import datetime
import matplotlib.pyplot as plt
import matplotlib.axes as axes
import matplotlib.docstring as docstring
import matplotlib.projections
import matplotlib.widgets
import pandas.core.tools.datetimes as tools
import datetime as pydt
from pandas.core.dtypes.common import (
    is_float,
    is_float_dtype,
    is_integer,
    is_integer_dtype,
)
from pandas import Index, Series
import pandas.core.common as com
        
from matplotlib.backend_tools import ToolToggleBase
with warnings.catch_warnings():
    warnings.simplefilter("ignore")
    plt.rcParams['toolbar'] = 'toolmanager'

converter = mdates.ConciseDateConverter()
munits.registry[np.datetime64] = converter
munits.registry[datetime.date] = converter
munits.registry[datetime.datetime] = converter


class DataDisplayDownsampler(object):
    ''' 
    A class that will downsample the data before plotting / zooming / panning.
    '''
    def __init__(self):
        self.line_list= []
        self.max_points = 10000
        self.origXData = []
        self.origYData = []
        
    def addlines(self, lines):
        ''' 
        Add a matplotlib.lines.Line2D or list of matplotlib.lines.Line2D objects to DataDisplayDownsampler object
        '''

        if  isinstance(lines, (matplotlib.lines.Line2D,)):
            self.line_list.append(lines)
            self.origXData.append(lines.get_xdata())
            self.origYData.append(lines.get_ydata())
            # self.dsparams.append([len(self.origXData), len(self.origXData), len(self.origXData)])

        elif isinstance(lines, list):
            for line in lines:
                self.line_list.append(line)
                xdata= line.get_xdata()
                ydata= line.get_ydata()
                self.origXData.append(xdata)
                self.origYData.append(ydata)
                # self.dsparams.append([len(self.origXData), len(self.origXData), len(self.origXData)])
        else:
            raise Exception("lines parameter has wrong type.")


    def downsample(self, line_num, xstart, xend):
        ''' 
        downsample plot data

        '''
        if self.max_points < 1:
            return self.origXData[line_num], self.origYData[line_num]
        else:
            # get the points in the view range
            origXData= self.origXData[line_num]
            
            def convert (x, xdat):
                if isinstance(xdat, (datetime.datetime, pydt.date, np.datetime64, pydt.time)):
                    return mdates.num2date(x),xdat
                elif is_integer(xdat) or is_float(xdat):
                    return x, xdat
                elif isinstance(xdat, str):
                    try:
                        mdates.date2num(tools.to_datetime(xdat))
                        return mdates.num2date(x),xdat
                    except Exception:
                        return x, xdat
                elif isinstance(xdat, (list, tuple, np.ndarray, Index, Series)):
                    if isinstance(xdat, Series):
                        # https://github.com/matplotlib/matplotlib/issues/11391
                        # Series was skipped. Convert to DatetimeIndex to get asi8
                        xdat = Index(xdat)
                    if isinstance(xdat, Index):
                        xdat = xdat.values
                    if not isinstance(xdat, np.ndarray):
                        xdat = com.asarray_tuplesafe(xdat)
                    if is_integer_dtype(xdat) or is_float_dtype(xdat):
                        return x, xdat
                    try:
                        xdat = tools.to_datetime(xdat)
                    except Exception:
                        if isinstance(xdat, np.ndarray) and xdat.dtype == pd.Period:
                            # we get here for pd.Period array (generated when generated by pd.DataFrame.plot() or pd.Series.plot())
                            xdat = pd.PeriodIndex(xdat).to_timestamp()
                            x0= pd.Period._from_ordinal(x[0], freq='s').to_timestamp()
                            x1= pd.Period._from_ordinal(x[1], freq='s').to_timestamp()
                            x = (x0, x1)
                            return x, xdat
                        # pass
                    
                    x = mdates.num2date(x)
                return x, xdat
            
            (xstart, xend), xdat = convert((xstart, xend), origXData)
            
            # resample selected data...
            
            if xdat.dtype == np.dtype('datetime64[ns]'):
                if hasattr(xstart, 'tzinfo') and xstart.tzinfo is not None and xstart.tzinfo.utcoffset(xstart) is not None:
                    xstart = xstart.replace(tzinfo=None)
                if hasattr(xend, 'tzinfo') and xend.tzinfo is not None and xend.tzinfo.utcoffset(xend) is not None:
                    xend = xend.replace(tzinfo=None)
                if type(xstart) != np.dtype('datetime64[ns]'):
                    xstart = np.datetime64(xstart)
                if type(xend) != np.dtype('datetime64[ns]'):
                    xend = np.datetime64(xend)

            # elif not (is_integer_dtype(xdat) or is_float_dtype(xdat)):
            #     raise NotImplementedError('Downsampling axes not implemented for data of dtype ' + str(xdat.dtype))
            
            mask = (xdat >= xstart) & (xdat <= xend)
            # dilate the mask by one to catch the points just outside
            # of the view range to not truncate the line
            if len(xdat)>2:
                mask = np.convolve([1, 1, 1], mask, mode='same').astype(bool)
            else:
                mask = np.convolve([1, 1], mask, mode='same').astype(bool)
            if np.sum(mask)==0: # If x zoom range does not comprise any data point,
                # try to use the nearest two data points left and right from the
                # zoom x-range, less if they don't exist
                left = np.argsort(np.abs((xdat - xstart)))
                mask[left[:min(2,left.size)]]=True
                right = np.argsort(np.abs((xdat - xend)))
                mask[right[:min(2,right.size)]]=True
                    
            # sort out how many points to drop
            ratio = max(np.sum(mask) // int(np.ceil(self.max_points)/5), 1)

            # mask data
            xdata = origXData[mask]
            ydata = self.origYData[line_num][mask]
            
            # downsample data:
            # The idea is to subdivide xdata into intervals and determine suitable
            # downsampled grid points. These are at 1/4, 1/2 nd 3/4 of each
            # interval, plus the max and min over each interval. In this way, on
            # one hand, extreme values are not missed, and intermediate values are
            # sampled as well.

            # temporarily pad to make array reshapable using ratio for subdivision
            # into intervals
            N = len(xdata)
            numpad = (ratio - (N % ratio)) % ratio # number of elements needed for padding
            if (numpad != 0): # pad only if necessary
                xdata = np.concatenate((xdata,xdata[0:numpad]),0)
                ydata = np.concatenate((ydata,ydata[0:numpad]),0)
            xdata = xdata.reshape(-1,ratio)
            ydata = ydata.reshape(-1,ratio)

            # get indices at downsampled x values (at 1/4, 1/2 and 3/4 of each interval)
            offs= np.floor(ratio/2).astype(int)
            offs2=np.floor(ratio/4).astype(int)
            ind_sliced = np.arange(offs,ratio*len(xdata),ratio).astype(int) #
            dummy = ydata.astype(float)
            dummy[np.isnan(dummy)] = np.nanmean(dummy)
            ind_max = np.argmax(dummy,axis=1)+ind_sliced-offs # also find maximum in each interval
            ind_min = np.argmin(dummy,axis=1)+ind_sliced-offs # also find minimum in each interval
            ind = np.unique((ind_sliced,ind_sliced-offs2,ind_sliced+offs2,ind_max,ind_min))

            xdata = xdata.flatten()[ind[ind<N]]
            ydata = ydata.flatten()[ind[ind<N]]
            
        return xdata, ydata

    def update(self, ax):
        xstart, xend  = ax.get_xlim()
        line_num= 0
        for line in self.line_list:
            line.set_data(*self.downsample(line_num,xstart, xend))
            line_num= line_num+1
        ax.figure.canvas.draw_idle()

class toggle_downsampling(ToolToggleBase):
    '''
    Toggle downsampling on and off
    '''
    
    # def __init__(self, *args, **kwargs):
    #     super().__init__(*args, **kwargs)
    
    name = 'Erik'
    # for pyQt >=5, the real image filename must have a suffix _large.png
    # compared to the name given here
    image = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe()))) + r'/downsampling_icon.png'
    
    # keyboard shortcut
    default_keymap = 'd'
    description = 'Toggle Downsampling on and off'
    default_toggled = True
    
    
    def enable(self, *args,**kwargs):
        # for all axes in figure, set the downsampler max_points attribute to 10000
        axes=self.figure.axes
        for ax in axes:
            # check if ax is dsaxes or axes.Axes object, only execute if dsaxes
            if isinstance(ax, dsaxes):
                ax.downsampler.max_points= 10000
                ax.downsampler.update(ax)
            else:
                pass

    def disable(self, *args,**kwargs):
        # for all axes in figure, set the downsampler max_points attribute to -1, for which all points will be plotted (no downsampling)
        axes=self.figure.axes
        for ax in axes:
            # check if ax is dsaxes or axes.Axes object, only execute if dsaxes
            if isinstance(ax, dsaxes):
                ax.downsampler.max_points= -1
                ax.downsampler.update(ax)
            else:
                pass

class dsaxes(axes.Axes):
    # docstring inherited
    '''
    Class similar to Axes, but allowing downsampling of plot lines
    and an interactive legend.
    '''
    name_ = 'dsaxes'
    def __init__(self,fig, rect):
        super().__init__(fig, rect)
        self.downsampler= DataDisplayDownsampler()
        
        self.callbacks.connect('xlim_changed', self.downsampler.update)
        #create, assign and toggle on toolbar button
        if 'Downsample' not in self.figure.canvas.manager.toolmanager.tools:
            self.figure.canvas.manager.toolmanager.add_tool('Downsample', toggle_downsampling)
            self.figure.canvas.manager.toolbar.add_tool('Downsample', 'zoompan', 2)
        
    @docstring.dedent_interpd
    def plot(self, *args, scalex=True, scaley=True, **kwargs):
        # docstring inherited
        
        args_ = []
        for xdata in args:
            if isinstance(xdata, np.ndarray) and isinstance(xdata[0], pd.Period):
                xdata = pd.PeriodIndex(xdata).to_timestamp()
            args_.append(xdata)
        lines = super().plot(*args_, scalex=True, scaley=True, **kwargs)
            
        self.downsampler.addlines(lines)
        self.downsampler.update(self)
        return lines
    
    
    def legend(self, *args, interactive=True, **kwargs):
        # docstring inherited
        '''
        Interactive legend if interactive==True,
        1) Hovering the Mouse cursor over the lines in the legend, 
           the associated line is brought to the front.
        2) Clicking on a line in the legend,
           the associated line is toggled hidden / visible.

        Parameters
        ----------
        bool interactive
        See Axes.legend() help for inherited arguments.

        Returns
        -------
        None.

        '''
        self.leg= super().legend(*args,**kwargs)
        if interactive:        
            pickables = dict()
            for legline, origline in zip(self.leg.get_lines(), self.get_lines()):
                legline.set_picker(True)  
                legline.set_pickradius(4)  # 4 pts tolerance
                pickables[legline] = origline
                
            def onpick(event):
                tl_state = self.figure.get_tight_layout()
                self.figure.set_tight_layout(False)
                legl = event.artist
                origline = pickables[legl]
                visible = not origline.get_visible()
                origline.set_visible(visible)
                legl.set_visible(visible)
                if visible:
                    zorders=[lin.get_zorder() for lin in self.get_lines()]
                    zordermax = max(zorders)
                    origline.set_zorder(zordermax+1e-14)
                self.figure.canvas.draw()
                self.figure.set_tight_layout(tl_state)
            self.figure.canvas.mpl_connect('pick_event', onpick)
            
            def hover(event):
                if event.canvas == self.figure.canvas:
                    tl_state = self.figure.get_tight_layout()
                    self.figure.set_tight_layout(False)
                    for line in pickables.keys():
                        cont,_ = line.contains(event)
                        if cont:
                            origline = pickables[line] 
                            zorders=[lin.get_zorder() for lin in self.get_lines()]
                            zordermax = max(zorders)
                            origline.set_zorder(zordermax+1e-14)
                    self.figure.canvas.draw()
                    self.figure.set_tight_layout(tl_state)
            self.figure.canvas.mpl_connect('motion_notify_event', hover)

class switch():
    def set_state(self, on=None):
        ''' activate downsampled rectangular plotting
        '''
        if on == None:
            on = not self.get_state()
        if on:
            matplotlib.projections.register_projection(dsaxes)
        else:
            matplotlib.projections.register_projection(axes.Axes)

    def get_state(self):
        # A bit dirty way to determine the state:
        # We need to open a fake figure and determine the state from the axes.
        # If we named the dsaxes class with the registration-relevant name 
        # "name" instead of "name_", we would not overload the plt methods
        fig = plt.figure()
        ax = plt.gca()
        if hasattr(ax,'name_') and ax.name_=='dsaxes':
            s = True
        else:
            s = False
        plt.close(fig=fig)
        return s

def main():
    converter = mdates.ConciseDateConverter()
    munits.registry[np.datetime64] = converter
    munits.registry[datetime.date] = converter
    munits.registry[datetime.datetime] = converter
    
    ds = switch()
     
    N=1e4
    t= np.arange(N)/N
    y= np.random.randn(int(N))
    y[3]=np.nan
    y1=pd.DataFrame(index= pd.date_range('2019',periods=N, freq='S'), data=y)
    ds_state = ds.get_state()
    
    ds.set_state(True)
    plt.close(fig=2)
    plt.figure(2)
    ax = plt.axes()
    ax.plot(y1.index, y1.values,'o',label='1') # plots nicely as defined by ConciseDateConverter
    ax.plot(y1.index, y1.values, linestyle= '-',label='2') # plots nicely as defined by ConciseDateConverter
    ax.legend(interactive=False)
    
    plt.close(fig=3)
    plt.figure(3)
    ax = plt.axes()
    y1.plot(ax=ax, marker='o', linestyle= 'None') # plots nicely as defined by ConciseDateConverter
    y1.plot(ax=ax, linestyle= '-') # plots nicely as defined by ConciseDateConverter

    plt.close(fig=4)
    plt.figure(4)
    ax = plt.axes()
    plt.plot(t,y,'o')
    plt.plot(t,y,'-')
    ax.legend(['1','2'], interactive=False)
    
    ds.set_state(ds_state)
    
# this means that if this script is executed, then
# main() will be executed
if __name__ == '__main__':
    main()
